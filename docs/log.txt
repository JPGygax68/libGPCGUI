2015-02-03
==========

- One thing I had not thought about yet: I just noticed that Windows (among else) uses smooth transitions to indicate view state changes (e.g. hovering/leaving a button changes its color, but smoothly)

- Maybe it's time, at this point, to think about theming.
  - Generalize the notion of "view state", so that change to any view state would automatically trigger a repaint ?

- I think animations should be kept outside of view state proper - though it must be able to trigger repaints.

- In some scenarios, it might make sense to do repaints immediately after the event triggering them - perhaps this could be a template specialization as well ?

---

### Theming - brainstorming

- Definition: make the association between view states and visual aspect customizable.

- Define arithmetics for colors ?

- Mix in theming via multiple inheritance ?

- For right now, use color interpolation. E.g. button:
  - define base colors (border, face)
  - derive hover and "active" variants (button down)
  - Theme:
    - area border color, inactive
    - area border color, "default" (for default button in a dialog)
    - area background color, inactive
    - area background color, hovered
    - area background color, focused
    - area background color, active (button down)

- All these colors should come from a theme definition that can be used by all widgets.

- Injecting "theming engine" into widget implementations
  - Same class for all widgets, or specific to widget type ?
  - Interface methods:
    - drawBorder()
    - drawBackground()
    - drawOverlay()

2015-01-28
==========

Quick notes:

- I've implemented a method to draw bevels in the Widget class. I'm not sure this is the right place; maybe a separate toolbox would be better.

- I'm still looking for a better term to replace "area" to express the combination of a width and a height. Not sure right now why I dissed "extents".

- I've defined Renderer::rgba_to_native() to be static methods. This could save some cycles because needed native colors can now easily be prepared as static constant values.

2015-01-26
==========

- GUI: "forced repaint" mode for when using double buffering or buffer must be redrawn for any other reason ?
  - Renderer parameter ? const parameter ?

- Order: layout - graphic resources - paint

- TODO: x_abs and y_abs are ill-named

2015-01-25
==========

Though it's very easy to store a collection of event handlers using std::function<> and std::vector<>, there seems to be no easy way to remove a handler from the collection due to the fact that std::function<> does not support an equality operator.

So, should I:

a) altogether drop the idea of supporting multiple event handlers per event ?
b) support detaching all event handlers at the same time ?

I've opted for (b) for now.

Next question: should event handlers get a pointer to the widget ? I think YES, as that would allow assigning a shared event handler to a collection of widgets.

---

Another question: how about providing events as widget "properties" (i.e. methods returning object references), so that one could write:

  my_button.mouseExit().addHandler( ... );
  
This would also remove the need for code duplication (but does it incur a footprint cost because of a need to point back to the widget?).

---

Just noted an inconvenience - when specifying lambda event handlers, one needs to specify the full type of the Widget parameter, which can be inconvenient as it needs template parameters.

In a real future application, the widget types will likely come from an already available templated struct. Still, it might be beneficial to support overloads of addXXXXHandler() that just throw away that parameter (and possibly the others as well) to support unencumbered user code. (Of course, a full parameterless callback only makes sense if the event is "signal-like" - i.e., the fact that it's been fired at all can be considered useful information in and of itself.)


2015-01-20 (evening)
==========

How to handle fonts and other resources that must eventually be handled by the GPU ?

On the GUI side, fonts are actually (pointers to) RasterizedFont objects. A GPU-based renderer will usually have to process those objects and upload some of that data (namely, the pixels) into GPU memory, returning a handle to the caller that the caller must provide again to actually render text. I call the process of creating a renderer-specific handle from a RasterizedFont object "registering" the font with the renderer (but perhaps a better term can and should be found).

Registering fonts is something that requires an active renderer, yet does not actually produce output. Because of that, it is probably a good idea to give user code a chance to trigger this independently of the rendering itself.

The question arises whether or not a widget should be allowed to change its font(s) when it has already been renderered (and thus has obtained a renderer-specific handle for its font). The alternative would be to mandate that the widget be re-created in such as case. This might make the implementation of a GUI designer somewhat less easy, especially since the question of serialization has not been discussed at all yet.

Assuming that yes, widgets can change fonts, the question arises how to manage this. Assigning a different rasterized font must trigger two things: releasing the old handle, and obtaining a new one. Both should take place before the next rendering pass, but not as a part of said rendering. And it cannot be done right away (synchronously), because the renderer is only available during rendering.

Before going further, I must question that assertion. I have trouble coming up with a scenario where it would be difficult to get access to the renderer at an arbitrary time. Though it is conceivable to have a renderer that is incapable of doing any drawing except when being called from the windowing system, it is very unlikely that the renderer would not still be able to access its resource pool at any time - that would almost imply that the resource pool is only available from a specific thread. Which, come to think of it, is actually a possibility - is there a CPU/GPU combination where only a specific core is able to communicate with the GPU ?

Thinking (and Googl'ing) some more, using a GL context (on which a renderer typically sits) from any thread *does* invite potential problems. In Windows for example, it is stated that a given GL context should only be made "current" in one thread at a time.

So, to sum up, there are two ways to go here:

- Decide that the renderer can be used at any time. This may make it necessary that the root widget call back to user code in order to "lock" the renderer. The advantage is that there is no need to defer registering and unlinking of renderer resources.

- Or provide hooks for user code to call at opportune times (possibly, though not ideally, from different threads than the rendering thread). This implies either keeping lists of things to allocate and free, or setting "dirty" flags that propagate up the widget tree up to the root widget.


2015-01-20
==========

The current approach to size calculations / layouting has a fundamental problem: it relies on the renderer for calculating text extents, which is nearly always needed when calculating the size and internal layout of a widget. 

This is wrong in the sense that it is an unnecessary dependency: the pixel size of a piece of text will never depend on what renderer is being used to display things.

That in itself is not a show-stopper. However, it makes it impossible to do layout calculations without passing the renderer around, which means that the "preferred size" of a widget cannot be treated like a (computed and read-only) property, but can only be obtained during an explicit layouting pass. This is impractical; in particular, it would make GUI designer tools cumbersome.


2015-01-19
==========

Todos at this point:

- Decide how to handle auto-sizing of widgets:
  - minWidth(), minHeight(): computed, set externally, or both ?
  - or just silently adjust externally set size ?
  - or interpret size = 0 as "auto" ?
  
- Trigger repaint when view-model state changes
  - but avoid recursion crash
  - actually a simple button doesn't have state
  
- Trigger repaint when view state changes
  -> implement display region invalidate
  
- Implement alignment
